-- 9월 14일 3주차 수업 내용

Scanner scanner = new Scanner(System.in);
=> scanner이라는 버튼을 만들어서 저걸 실행하기 쉽게 만든 듯,
	저거는 키보드로 입력받겠다는 명령어..?
int x = scanner.nextInt();
=> scanner 버튼 누르고 int로 데이터를 읽어들인다.. 입력해주길 기다리는 명령어
	next~ 이런거 왕 많음..
정보은닉
캡슐화..
컴파일 => 구문분석(lexical analyser) -> 파싱(parsing)
	ex) a = b + c; 를 a, = , b, +, c, ; 이런 식으로 나눠져있는걸 토큰이라고 함
	=> 파싱트리..?  x <- = -> + ->> a, b

** 자바 가상 머신은 기본적으로 32비트 단위도 계산되어 
byte b1 = 1;
byte b2 = 2;
byte b3 = b1 + b2; -> 오류발생
=> 1 + 2 = 3이더라도 자바 가상 머신이 32비트에 저장하여 오류가 된다..?

(비트연산자) 시프트 -> 비트를 좌우로 이동한다
~ 틸드? ^ 캐럿 & 앤퍼센트

XOR(^)은 베타적인거라 둘이 달라야 true가 나옴

연산자 후위형, 전위형.. 제대로 알고 있으라고 하셧음
우선순위랑 결합규칙도

조건문, 반복문 if, if ~ else ~ / while, do ~ while, for / break, continue

-- 10월 5일 수업내용

객체지향 (Object-Oriented)
개념 -> 캡슐화 (encapsulation) -> data
문제가 생겼을 때 클래스 부분만 확인하면 된다..

생성자는 메서드와 비슷하지만, 이름이 클래스 이름과 같고 반환 타입 없음
생성자는 객체가 생성될 때 필드를 초기화하거나 객체 사용을 준비한다
new 연산자와 함께 생성자를 실행하면 객체가 생성되고 해당 객체의 주소를 반환한다

=> 클래스이름 변수 = new 클래스이름(...);
~ 생성자 이름은 클래스 이름과 같고, 생성자 반환 타입은 없음, 생성자는 new 연산자와 함께 사용, 객체를 생성할 때 호출, 생성자도 오버로딩할 수 있다

-디폴트 생성자와 생성자 오버로딩
클래스 안에 있는 함수 -> 생성자?
클래스 안에 다른 생성자가 있으면 디폴트 생성자가 추가되지 않는다

-this와 this()
클래스 안에 
private double side;
public void setRadius(double s) {
	side = s;
}
이거랑
public void setRadius (double side) {
	this.side = side;
}
이거는 똑같다?
this는 제일 먼저 해야한다?
this.side = side
여기서 앞 부분 this랑 있는 side는 함수 바깥에 있는 side, 뒷 부분 side는 함수의 매개변수이므로 클래스 안의 함수에서 클래스 안 중 제일 바깥 쪽의 변수에 넘겨주기 위해서 사용하는 듯 -> 다른 함수에서도 쓸 수 있도록

-연속호출
Person person = new Person();
person = person.setName("민국");
person = person.setAge(21);
person.sayHello();
=
Person person = new Person();
person.setName("민국").setAge(21).sayHello();

-정적멤버
-인스턴스 멤버와 정적 멤버
-정적멤버의 활용
클래스 안에 static으로 정적 변수를 두면 객체마다 별도의 기억 공간을 사용하더라도 초기화되지 않는다

-정적블록
정적블록으로 정적변수 초기화

-문자열의 다양한 연산
173p 참고

-배열
변수 선언하고 초기화하는 방법 179p ~ 180p 사진 시험
예제 5-6번의 scores.length 부분 괄호쳐서 나올 듯?

-- 10월 12일 수업내용
-다차원 배열
2차원 -> 테이블
인덱스(행) 열(column) ㄱ자로 가로 행, 세로 열 배열 선언에서는 앞 행, 뒤 열

-동적배열
앞에서 배웠던 것들은 정적배열
정적배열의 단점은 0.1과 0.2 사이에 0.15를 넣을 때 한 칸씩 밀고 넣는 점..?
동적배열은 이런 상황에서 그냥 포인터 부분을? 주소를 수정하는 방법으로 효율적
수정하는 부분에서는 동적배열이 좋지만 뭐 찾는거는 정적이 빠르다?
처리할 데이터이 개수가 고정된 경우가 아니면 정적배열은 자원 낭비 or 프로그램을 다시 컴파일
자바는 크기가 유동적인 배열을 지원하기 위해 ArrayList 클래스 제공
참조, reference
참조변수가 동적배열을 가르키고 있다...
ArrayList<참조타입> 참조변수 = new ArrayList<>();
기초 타입의 동적 배열이라면 Integer, long, Short, Float, Double, Charter, Boolean 등을 사용한다
int, char는 기초타입? 기본타입이고 이거는 다른 참조타입?
ArratList 원소 접근 => 참조변수.add(데이터), 참조변수.remove(인덱스 번호), 참조변수.get(인덱스번호), 참조변수.size()

-배열을 위한 반복문
for (타입 변수 : 배열 혹은 컬렉션)

-메서드의 인수로 배열 전달
parameter passing(파라미터 전달)
 - call-by-value(값)
 - call-by-reference(주소)

-메인 메서드의 매개변수 전달
run 아이콘 옆에 있는 화살표 눌러서 Argument창에 인수 입력할 것

-가변 개수 매개변수
190p 예제 해보기

-객체의 배열
객체를 참조하는 주소를 원소로 구성
예) Ball 클래스의 객체로 구성된 배열을 선언하고 초기화
Ball[] balls = new Ball[5]; -> 5개의 Ball 객체 생성 X, 객체를 참조할 변수 준비
생성자는 이 후에 호출하여 Ball 객체 생성해야 함
-> for (int i = 0; i < 2; i++)
	balls[i] = new Ball();

-- 10월 26일 수업내용
-상속의 개념 214p
여러 클래스에서 공통으로 필요한 필드나 메서드가 있을 경우 필드나 메서드를 수정할 때 해당 내용이 있는 클래스 모두에서 해야함. 이는 중복된 코드를 발생시키고 유지 보수하기 어렵게 만듦. 해서 공통된 부분을 통합해 새로운 클래스를 만들고 이 새로운 클래스를 상속해 개별 클래스를 만든다면 코드가 간결하고 관리도 편함. -> 상속
객체지량 -> 클래스
재사용, 개발편의 -> 다시 사용
부모 - 자식 관계 : 상속

자식 클래스는 대체로 부모 클래스보다 속성이나 동작이 더 많음
ㄴ 자식 클래스는 부모 클래스에서 물려받은 멤버를 그대로 사용, 변경, 추가 가능

기본클래스 (bass)
파생클래스(derived)
자식은 부모를 확장한다..
Eagle extend Animal
다만 다중상속은 인터페이스를 통해 구현

-메서드 오버라이딩
ParentsChildren1Demoproject로 보는 메서드 오버라이딩
Ball에 없는 findArea가 선언되자 Ball의 부모 클래스인 Circle의 findArea를 들고 옴
오버라이딩 -> 부모 클래스의 것을 자식 클래스에 맞도록 수정한다 (상속관계에서만)

-메서드 오버라이딩
메서드 이름 동일, 매개변수 동일, 반환 타입 동일, 상속관계 필요, 예외와 접근 범위 제약 있음, 호출할 메서드를 실행 중 결정하는 동적 바인딩
-메서드 오버로딩
메서드 이름 동일, 매개변수 다르고, 반환타입 관계없고, 상속관계 필요 없음, 예외와 접근 범위 제약도 없고 호출할 메서드를 컴파일할 때 결정하는 정적 바인딩

-패키지
클래스 파일을 묶어서 관리하기 위한 수단으로 파일 시스템의 폴더를 이용
패키지 이름은 모두 소문자로 명명하는 것이 관례, 일반적으로 패키지 이름이 중복되지 않도록 회사의 도메인 이름을 역순으로 사용

-자식 클래스와 부모 생성자

-상속과 접근 제어
private 멤버는 동일 패키지 내의 동일 클래스에서만 접근 가능
protected 멤버는 동일 패키지(디렉토리?) 내의 일반, 자식, 동일 클래스와 다른 패키지의 자식 클래스는 접근 가능
public 멤버는 아무나 다 접근 가능
default 멤버는 동일 패키지 내의 클래스에서만 접근 가능

-final 클래스와 메서드

-객체의 타입 변환
참조 타입 데이터도 기초 타입 데이터처럼 타입 변환 가능
그러나 상속 관계일 경우만 타입 변환 가능
기초 타입처럼 자동 타입 변환과 강제 타입 변환이 있음
Student s = new Student();
Person p = s; // 자동으로 타입 변환
여기서 p가 부모고 s가 자식이 돼서 p는 여전히 whoami만 사용 가능
부모가 자식을 가르킨다..
자식은 부모를 가르킬 수 없다..

-타입 변환된 객체의 구별
변수가 참조하는 객체의 실제 타입을 식별하는 instanceof 연산자 제공
instanceof 연산자는 변수가 해당 타입이나 자식 타입이라면 true를 반환하고, 그렇지 않다면 false를 반환한다. 그러나 변수가 해당 타입과 관련이 없다면 오류 발생

- 인터페이스 기초 (다중상속)
.인터페이스에 의한 장점
인터페이스만 준수하면 통합에 신경쓰지 않고 다양한 형태로 새로운 클래스를 개발할 수 있다
클래스의 다중 상속을 지원하지 않지만, 인터페이스로 다중 상속 효과를 간접적으로 얻을 수 있다
.인터페이스의 예
자바가 기본적으로 제공하는 인터페이스는 다양
.예를 들어, 객체의 크리를 비교하는 Comparable 인터페이스는 다음과 같다
public interface Comparable<T> {
	int compareTo(T o);
}
interface  extends

- 중첩 클래스와 중첩 인터페이스
.익명 클래스

-- 함수?
- java.lang패키지
Object 최상위 클래스로 기본적인 메서드를 제공한다
- StringTokenizer
토큰(Token)
ex) a=b+c; -> a, =, b, +, c, ;
331p delim = 구분자

-- 예외처리 및 제너릭 프로그래밍
- 예외
에러 : 개발자가 해결할 수 없는 치명적인 오류
예외 : 개발자가 해결할 수 있는 오류
-> 예외가 발생하면 비정상적인 종료를 막고, 프로그램을 계속 진행할 수 있도록 우회 경로를 제공하면 좋음
exception hendling - 예외 처리
Exception - 1. 검사형 예외
	    2. RuntimeException(수행) 1) 비검사형 예외(실행예외)
- 실행예외
프로그램 실행 도중 예외 발생 시, jvm은 해당하는 실행 예외 객체 생성
표 9-1, 353p
- 일반예외

-예외 처리 방법
1. 예외 잡아 처리하기
try {

} catch (예외클래스1 참조변수) {
	핸들러;
}

try {
	예외가 발생할 수 있는 실행문
} catch (예외클래스1 | 예외클래스 2 참조변수) {
	핸들러;
} catch (예외클래스3 변수) {
	핸들러;
} finally {
	예외 발생 여부와 관계없이 수행할 실행문;
}


2. 예외 떠넘기기
메서드에서 발생한 예외를 내부에서 처리하기 부담스러울 때 throws로 
public void write(String filename)
	

-- 제너릭 타입
하나의 코드를 다양한 타입의 객체에 재사용하는 객체 지향 기법
클래스, 인터페이스, 메서드를 정의할 때
class 클래스 이름 <타입매개변수> {
	필드;
	메서드;
}
타입 매개변수는 객체를 생성할 대 구체적인 타입으로 대체
제너릭 클래스 <적용할 타입> 변수 = new 제너릭클래스 <적용할타입> ();
// 뒤 쪽 다이아몬드 연산자 생략 가능
Object -> 제너릭 타입 매개변수